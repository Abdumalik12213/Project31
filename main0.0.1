import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import sqlite3
import requests
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
import json
import os
from PIL import Image, ImageTk
import io
import threading
import time
import re
import csv
import webbrowser
import logging
import urllib3
from dataclasses import dataclass
from typing import Optional

# –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('price_monitor.log'),
        logging.StreamHandler()
    ]
)

@dataclass
class Product:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ç–æ–≤–∞—Ä–µ"""
    id: int
    name: str
    url: str
    current_price: Optional[float]
    previous_price: Optional[float]
    currency: str
    last_updated: str
    selector_path: str
    image_data: Optional[bytes] = None
    category: str = "–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"

class PriceMonitorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("üí∞ Price Monitor")
        self.root.geometry("1200x700")
        
        # –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–∫–Ω–∞
        self.center_window()
        
        # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        self.conn = None
        self.create_database()
        
        self.current_product_id = None
        self.update_thread = None
        self.stop_update = False
        
        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.config = self.load_config()
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        self.create_widgets()
        
        # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        self.load_products()
        
        # –ó–∞–ø—É—Å–∫ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        if self.config.get('auto_update', False):
            self.start_auto_update()
    
    def center_window(self):
        self.root.update_idletasks()
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        x = (screen_width - 1200) // 2
        y = (screen_height - 700) // 2
        self.root.geometry(f'1200x700+{x}+{y}')
    
    def create_database(self):
        try:
            self.conn = sqlite3.connect('price_monitor.db', check_same_thread=False)
            cursor = self.conn.cursor()
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    url TEXT NOT NULL,
                    category TEXT DEFAULT '–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏',
                    image_data BLOB,
                    current_price REAL,
                    previous_price REAL,
                    currency TEXT DEFAULT 'RUB',
                    last_updated TEXT,
                    selector_path TEXT,
                    target_price REAL,
                    is_active INTEGER DEFAULT 1
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS price_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER,
                    price REAL NOT NULL,
                    date TEXT NOT NULL,
                    FOREIGN KEY (product_id) REFERENCES products (id) ON DELETE CASCADE
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS settings (
                    key TEXT PRIMARY KEY,
                    value TEXT
                )
            ''')
            
            self.conn.commit()
            
        except sqlite3.Error as e:
            logging.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {e}")
            messagebox.showerror("–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö:\n{e}")
    
    def load_config(self):
        config = {
            'update_interval': 300,
            'auto_update': False,
            'notifications': True,
            'currency': 'RUB'
        }
        
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT key, value FROM settings")
            for key, value in cursor.fetchall():
                if key in config:
                    if key == 'update_interval':
                        config[key] = int(value)
                    elif key in ['auto_update', 'notifications']:
                        config[key] = bool(int(value))
                    else:
                        config[key] = value
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
        
        return config
    
    def save_config(self):
        try:
            cursor = self.conn.cursor()
            for key, value in self.config.items():
                if isinstance(value, bool):
                    value = int(value)
                cursor.execute(
                    "INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)",
                    (key, str(value))
                )
            self.conn.commit()
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")
    
    def create_widgets(self):
        # –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="–§–∞–π–ª", menu=file_menu)
        file_menu.add_command(label="–≠–∫—Å–ø–æ—Ä—Ç –≤ CSV", command=self.export_data)
        file_menu.add_separator()
        file_menu.add_command(label="–í—ã—Ö–æ–¥", command=self.on_closing)
        
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã", menu=tools_menu)
        tools_menu.add_command(label="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", command=self.show_statistics)
        tools_menu.add_command(label="–ù–∞—Å—Ç—Ä–æ–π–∫–∏", command=self.show_settings)
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        left_frame = ttk.LabelFrame(main_frame, text="–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ", padding="10")
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        
        # –§–æ—Ä–º–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è
        ttk.Label(left_frame, text="–ù–∞–∑–≤–∞–Ω–∏–µ:").pack(anchor=tk.W)
        self.name_var = tk.StringVar()
        ttk.Entry(left_frame, textvariable=self.name_var, width=30).pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(left_frame, text="URL:").pack(anchor=tk.W)
        self.url_var = tk.StringVar()
        ttk.Entry(left_frame, textvariable=self.url_var, width=30).pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(left_frame, text="–ö–∞—Ç–µ–≥–æ—Ä–∏—è:").pack(anchor=tk.W)
        self.category_var = tk.StringVar()
        ttk.Entry(left_frame, textvariable=self.category_var, width=30).pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(left_frame, text="CSS-—Å–µ–ª–µ–∫—Ç–æ—Ä —Ü–µ–Ω—ã:").pack(anchor=tk.W)
        self.selector_var = tk.StringVar(value=".price, .product-price")
        ttk.Entry(left_frame, textvariable=self.selector_var, width=30).pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(left_frame, text="–¶–µ–ª–µ–≤–∞—è —Ü–µ–Ω–∞:").pack(anchor=tk.W)
        self.target_var = tk.StringVar()
        ttk.Entry(left_frame, textvariable=self.target_var, width=30).pack(fill=tk.X, pady=(0, 10))
        
        btn_frame = ttk.Frame(left_frame)
        btn_frame.pack(fill=tk.X)
        
        ttk.Button(btn_frame, text="–î–æ–±–∞–≤–∏—Ç—å", command=self.add_product).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="–û–±–Ω–æ–≤–∏—Ç—å", command=self.update_product).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="–û—á–∏—Å—Ç–∏—Ç—å", command=self.clear_form).pack(side=tk.LEFT, padx=2)
        
        ttk.Separator(left_frame, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=10)
        
        # –ö–Ω–æ–ø–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        ttk.Button(left_frame, text="–û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ —Ü–µ–Ω—ã", 
                  command=self.update_all_prices).pack(fill=tk.X, pady=2)
        ttk.Button(left_frame, text="–û–±–Ω–æ–≤–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–µ", 
                  command=self.update_selected_price).pack(fill=tk.X, pady=2)
        
        self.auto_var = tk.BooleanVar(value=self.config['auto_update'])
        ttk.Checkbutton(left_frame, text="–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ", 
                       variable=self.auto_var,
                       command=self.toggle_auto_update).pack(anchor=tk.W, pady=5)
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        self.info_text = scrolledtext.ScrolledText(left_frame, height=10, width=35)
        self.info_text.pack(fill=tk.BOTH, expand=True, pady=(10, 0))
        self.info_text.config(state=tk.DISABLED)
        
        # –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å - —Ç–∞–±–ª–∏—Ü–∞ —Ç–æ–≤–∞—Ä–æ–≤
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # –ü–æ–∏—Å–∫
        search_frame = ttk.Frame(right_frame)
        search_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(search_frame, text="–ü–æ–∏—Å–∫:").pack(side=tk.LEFT)
        self.search_var = tk.StringVar()
        self.search_var.trace('w', lambda *args: self.load_products())
        ttk.Entry(search_frame, textvariable=self.search_var).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        # –¢–∞–±–ª–∏—Ü–∞
        columns = ("ID", "–ù–∞–∑–≤–∞–Ω–∏–µ", "–ö–∞—Ç–µ–≥–æ—Ä–∏—è", "–¶–µ–Ω–∞", "–ò–∑–º–µ–Ω–µ–Ω–∏–µ", "–û–±–Ω–æ–≤–ª–µ–Ω–æ")
        self.tree = ttk.Treeview(right_frame, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=100)
        
        self.tree.column("–ù–∞–∑–≤–∞–Ω–∏–µ", width=200)
        self.tree.column("ID", width=50)
        
        scrollbar = ttk.Scrollbar(right_frame, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # –°–æ–±—ã—Ç–∏—è
        self.tree.bind('<<TreeviewSelect>>', self.on_product_select)
        self.tree.bind('<Double-1>', lambda e: self.open_in_browser())
        self.tree.bind('<Button-3>', self.show_context_menu)
        
        # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
        self.context_menu = tk.Menu(self.root, tearoff=0)
        self.context_menu.add_command(label="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å URL", command=self.copy_url)
        self.context_menu.add_command(label="–û—Ç–∫—Ä—ã—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ", command=self.open_in_browser)
        self.context_menu.add_command(label="–û–±–Ω–æ–≤–∏—Ç—å —Ü–µ–Ω—É", command=self.update_selected_price)
        self.context_menu.add_separator()
        self.context_menu.add_command(label="–£–¥–∞–ª–∏—Ç—å", command=self.delete_product)
        
        # –°—Ç–∞—Ç—É—Å –±–∞—Ä
        self.status_bar = ttk.Label(self.root, text="–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ", relief=tk.SUNKEN)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
    
    def get_categories(self):
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT DISTINCT category FROM products WHERE category != ''")
            return ["–í—Å–µ —Ç–æ–≤–∞—Ä—ã"] + [row[0] for row in cursor.fetchall()]
        except:
            return ["–í—Å–µ —Ç–æ–≤–∞—Ä—ã"]
    
    def load_products(self):
        try:
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            query = "SELECT id, name, category, current_price, previous_price, last_updated FROM products WHERE is_active = 1"
            params = []
            
            search = self.search_var.get().strip()
            if search:
                query += " AND (name LIKE ? OR category LIKE ?)"
                params.extend([f"%{search}%", f"%{search}%"])
            
            query += " ORDER BY last_updated DESC"
            
            cursor = self.conn.cursor()
            cursor.execute(query, params)
            
            for row in cursor.fetchall():
                product_id, name, category, current_price, previous_price, last_updated = row
                
                change_text = "‚Äî"
                if current_price and previous_price:
                    diff = current_price - previous_price
                    if diff > 0:
                        change_text = f"‚ñ≤ +{diff:.2f}"
                    elif diff < 0:
                        change_text = f"‚ñº {diff:.2f}"
                
                price_text = f"{current_price:.2f} ‚ÇΩ" if current_price else "‚Äî"
                
                self.tree.insert("", tk.END, values=(
                    product_id, name, category, price_text, change_text, last_updated
                ))
            
            self.status_bar.config(text=f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ —Ç–æ–≤–∞—Ä–æ–≤: {len(self.tree.get_children())}")
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
    
    def on_product_select(self, event):
        selection = self.tree.selection()
        if not selection:
            return
        
        item = self.tree.item(selection[0])
        product_id = item['values'][0]
        self.current_product_id = product_id
        
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT name, url, category, selector_path, target_price
                FROM products WHERE id = ?
            """, (product_id,))
            
            name, url, category, selector, target = cursor.fetchone()
            
            self.name_var.set(name)
            self.url_var.set(url)
            self.category_var.set(category)
            self.selector_var.set(selector)
            self.target_var.set(str(target) if target else "")
            
            info = f"–í—ã–±—Ä–∞–Ω: {name}\n–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {category}\nURL: {url[:50]}..."
            self.info_text.config(state=tk.NORMAL)
            self.info_text.delete(1.0, tk.END)
            self.info_text.insert(1.0, info)
            self.info_text.config(state=tk.DISABLED)
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–µ—Ç–∞–ª–µ–π: {e}")
    
    def show_context_menu(self, event):
        item = self.tree.identify_row(event.y)
        if item:
            self.tree.selection_set(item)
            self.context_menu.post(event.x_root, event.y_root)
    
    def add_product(self):
        name = self.name_var.get().strip()
        url = self.url_var.get().strip()
        
        if not name or not url:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ URL")
            return
        
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        
        try:
            target = float(self.target_var.get()) if self.target_var.get() else None
        except ValueError:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ü–µ–ª–µ–≤–∞—è —Ü–µ–Ω–∞")
            return
        
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO products (name, url, category, selector_path, target_price, last_updated)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            name,
            url,
            self.category_var.get() or "–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
            self.selector_var.get() or ".price",
            target,
            datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        ))
        
        self.conn.commit()
        self.load_products()
        self.clear_form()
        self.status_bar.config(text=f"–¢–æ–≤–∞—Ä '{name}' –¥–æ–±–∞–≤–ª–µ–Ω")
    
    def update_product(self):
        if not self.current_product_id:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä")
            return
        
        try:
            target = float(self.target_var.get()) if self.target_var.get() else None
        except ValueError:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ü–µ–ª–µ–≤–∞—è —Ü–µ–Ω–∞")
            return
        
        cursor = self.conn.cursor()
        cursor.execute("""
            UPDATE products SET name=?, url=?, category=?, selector_path=?, target_price=?
            WHERE id=?
        """, (
            self.name_var.get(),
            self.url_var.get(),
            self.category_var.get() or "–ë–µ–∑ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏",
            self.selector_var.get(),
            target,
            self.current_product_id
        ))
        
        self.conn.commit()
        self.load_products()
        self.status_bar.config(text="–¢–æ–≤–∞—Ä –æ–±–Ω–æ–≤–ª–µ–Ω")
    
    def clear_form(self):
        self.name_var.set("")
        self.url_var.set("")
        self.category_var.set("")
        self.selector_var.set(".price")
        self.target_var.set("")
        self.current_product_id = None
        
        self.info_text.config(state=tk.NORMAL)
        self.info_text.delete(1.0, tk.END)
        self.info_text.config(state=tk.DISABLED)
    
    def delete_product(self):
        selection = self.tree.selection()
        if not selection:
            return
        
        if messagebox.askyesno("–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ", "–£–¥–∞–ª–∏—Ç—å —Ç–æ–≤–∞—Ä?"):
            item = self.tree.item(selection[0])
            product_id = item['values'][0]
            
            cursor = self.conn.cursor()
            cursor.execute("DELETE FROM products WHERE id=?", (product_id,))
            self.conn.commit()
            
            self.load_products()
            self.clear_form()
            self.status_bar.config(text="–¢–æ–≤–∞—Ä —É–¥–∞–ª–µ–Ω")
    
    def copy_url(self):
        selection = self.tree.selection()
        if not selection:
            return
        
        item = self.tree.item(selection[0])
        product_id = item['values'][0]
        
        cursor = self.conn.cursor()
        cursor.execute("SELECT url FROM products WHERE id=?", (product_id,))
        url = cursor.fetchone()[0]
        
        self.root.clipboard_clear()
        self.root.clipboard_append(url)
        self.status_bar.config(text="URL —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω")
    
    def open_in_browser(self):
        selection = self.tree.selection()
        if not selection:
            return
        
        item = self.tree.item(selection[0])
        product_id = item['values'][0]
        
        cursor = self.conn.cursor()
        cursor.execute("SELECT url FROM products WHERE id=?", (product_id,))
        url = cursor.fetchone()[0]
        
        webbrowser.open(url)
    
    def extract_price(self, html, selector):
        try:
            soup = BeautifulSoup(html, 'html.parser')
            
            for sel in selector.split(','):
                sel = sel.strip()
                elements = soup.select(sel)
                if elements:
                    text = elements[0].get_text().strip()
                    # –ò—â–µ–º —Ü–µ–Ω—É –≤ —Ç–µ–∫—Å—Ç–µ
                    numbers = re.findall(r'[\d\s,.]*\d+[.,]?\d*', text)
                    if numbers:
                        price_str = numbers[0].replace(' ', '').replace(',', '.')
                        return float(price_str)
            
            return None
        except:
            return None
    
    def update_product_price(self, product_id, force=False):
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                SELECT url, selector_path, current_price, name 
                FROM products WHERE id=? AND is_active=1
            """, (product_id,))
            
            url, selector, current_price, name = cursor.fetchone()
            
            if not force:
                cursor.execute("SELECT last_updated FROM products WHERE id=?", (product_id,))
                last = cursor.fetchone()[0]
                if last:
                    try:
                        last_date = datetime.strptime(last, "%Y-%m-%d %H:%M:%S")
                        if datetime.now() - last_date < timedelta(minutes=5):
                            return True
                    except:
                        pass
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=15, verify=False)
            new_price = self.extract_price(response.text, selector)
            
            if new_price:
                cursor.execute("""
                    UPDATE products 
                    SET previous_price=?, current_price=?, last_updated=?
                    WHERE id=?
                """, (current_price, new_price, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), product_id))
                
                cursor.execute("""
                    INSERT INTO price_history (product_id, price, date)
                    VALUES (?, ?, ?)
                """, (product_id, new_price, datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
                
                self.conn.commit()
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–µ–≤–æ–π —Ü–µ–Ω—ã
                cursor.execute("SELECT target_price FROM products WHERE id=?", (product_id,))
                target = cursor.fetchone()[0]
                if target and new_price <= target:
                    self.show_notification("–¶–µ–ª—å –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞!", f"{name}\n–¶–µ–Ω–∞: {new_price:.2f} ‚ÇΩ")
                
                return True
            
            return False
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}")
            return False
    
    def update_selected_price(self):
        selection = self.tree.selection()
        if not selection:
            messagebox.showwarning("–û—à–∏–±–∫–∞", "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä")
            return
        
        item = self.tree.item(selection[0])
        product_id = item['values'][0]
        
        self.status_bar.config(text="–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ...")
        self.root.update()
        
        if self.update_product_price(product_id, force=True):
            self.load_products()
            self.status_bar.config(text="–¶–µ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞")
        else:
            self.status_bar.config(text="–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")
    
    def update_all_prices(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT id, name FROM products WHERE is_active=1")
        products = cursor.fetchall()
        
        if not products:
            messagebox.showinfo("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", "–ù–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")
            return
        
        def update():
            success = 0
            for product_id, name in products:
                if self.update_product_price(product_id):
                    success += 1
                time.sleep(2)
            
            self.root.after(0, lambda: self.load_products())
            self.root.after(0, lambda: self.status_bar.config(
                text=f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {success} –∏–∑ {len(products)}"
            ))
        
        threading.Thread(target=update, daemon=True).start()
    
    def toggle_auto_update(self):
        self.config['auto_update'] = self.auto_var.get()
        self.save_config()
        
        if self.config['auto_update']:
            self.start_auto_update()
        else:
            self.stop_auto_update()
    
    def start_auto_update(self):
        if self.update_thread and self.update_thread.is_alive():
            return
        
        self.stop_update = False
        
        def loop():
            while self.config['auto_update'] and not self.stop_update:
                time.sleep(self.config['update_interval'])
                if self.config['auto_update'] and not self.stop_update:
                    self.root.after(0, self.update_all_prices)
        
        self.update_thread = threading.Thread(target=loop, daemon=True)
        self.update_thread.start()
        self.status_bar.config(text="–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ")
    
    def stop_auto_update(self):
        self.stop_update = True
        self.status_bar.config(text="–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
    
    def show_statistics(self):
        cursor = self.conn.cursor()
        
        cursor.execute("""
            SELECT 
                COUNT(*) as total,
                COUNT(current_price) as with_price,
                AVG(current_price) as avg_price,
                MIN(current_price) as min_price,
                MAX(current_price) as max_price
            FROM products WHERE is_active=1
        """)
        
        stats = cursor.fetchone()
        
        msg = f"""üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:
        
–í—Å–µ–≥–æ —Ç–æ–≤–∞—Ä–æ–≤: {stats[0]}
–° —Ü–µ–Ω–∞–º–∏: {stats[1]}
–ë–µ–∑ —Ü–µ–Ω: {stats[0] - stats[1]}

–°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞: {stats[2]:.2f} ‚ÇΩ
–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è: {stats[3]:.2f} ‚ÇΩ
–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è: {stats[4]:.2f} ‚ÇΩ"""
        
        messagebox.showinfo("–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", msg)
    
    def show_settings(self):
        win = tk.Toplevel(self.root)
        win.title("–ù–∞—Å—Ç—Ä–æ–π–∫–∏")
        win.geometry("400x300")
        
        ttk.Label(win, text="–ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–º–∏–Ω):").pack(pady=5)
        interval_var = tk.StringVar(value=str(self.config['update_interval'] // 60))
        ttk.Entry(win, textvariable=interval_var).pack()
        
        ttk.Label(win, text="–í–∞–ª—é—Ç–∞:").pack(pady=5)
        currency_var = tk.StringVar(value=self.config['currency'])
        ttk.Combobox(win, textvariable=currency_var, 
                    values=['RUB', 'USD', 'EUR']).pack()
        
        notif_var = tk.BooleanVar(value=self.config['notifications'])
        ttk.Checkbutton(win, text="–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", variable=notif_var).pack(pady=5)
        
        def save():
            try:
                self.config['update_interval'] = int(interval_var.get()) * 60
                self.config['currency'] = currency_var.get()
                self.config['notifications'] = notif_var.get()
                self.save_config()
                win.destroy()
                messagebox.showinfo("–£—Å–ø–µ—Ö", "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")
            except:
                messagebox.showerror("–û—à–∏–±–∫–∞", "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª")
        
        ttk.Button(win, text="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", command=save).pack(pady=20)
    
    def export_data(self):
        cursor = self.conn.cursor()
        cursor.execute("""
            SELECT name, category, url, current_price, previous_price, last_updated
            FROM products WHERE is_active=1
        """)
        
        data = cursor.fetchall()
        
        if not data:
            messagebox.showinfo("–≠–∫—Å–ø–æ—Ä—Ç", "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")]
        )
        
        if filename:
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(['–ù–∞–∑–≤–∞–Ω–∏–µ', '–ö–∞—Ç–µ–≥–æ—Ä–∏—è', 'URL', '–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞', '–ü—Ä–µ–¥—ã–¥—É—â–∞—è —Ü–µ–Ω–∞', '–û–±–Ω–æ–≤–ª–µ–Ω–æ'])
                writer.writerows(data)
            
            self.status_bar.config(text=f"–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ –≤ {os.path.basename(filename)}")
    
    def show_notification(self, title, msg):
        if not self.config['notifications']:
            return
        
        win = tk.Toplevel(self.root)
        win.title(title)
        win.geometry("300x150")
        win.attributes('-topmost', True)
        
        ttk.Label(win, text="üîî", font=('Arial', 24)).pack(pady=10)
        ttk.Label(win, text=msg).pack(pady=10)
        ttk.Button(win, text="OK", command=win.destroy).pack(pady=10)
        
        self.root.after(5000, win.destroy)
    
    def on_closing(self):
        self.stop_auto_update()
        if self.conn:
            self.conn.close()
        self.root.destroy()

def main():
    root = tk.Tk()
    app = PriceMonitorApp(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()
